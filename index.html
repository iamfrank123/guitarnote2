<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description"
        content="Applicazione di training musicale per riconoscimento note - Chitarra e Pianoforte">
    <meta name="theme-color" content="#4f46e5">
    <title>Musical Training App</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/meyda/dist/web/meyda.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .mono-font {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Animations */
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes slideInUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes glow {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.8);
            }
        }

        .note-enter {
            animation: fadeInScale 0.3s ease-out;
        }

        .feedback-correct {
            animation: pulse 0.5s ease-in-out;
        }

        .feedback-bounce {
            animation: bounce 0.5s ease-in-out;
        }

        .slide-in-up {
            animation: slideInUp 0.4s ease-out;
        }

        .glow-effect {
            animation: glow 1.5s ease-in-out infinite;
        }

        .color-transition {
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }

        .status-idle {
            border-color: #6b7280;
            background-color: rgba(107, 114, 128, 0.1);
        }

        .status-correct {
            border-color: #10b981;
            background-color: rgba(16, 185, 129, 0.1);
        }

        .status-close {
            border-color: #f59e0b;
            background-color: rgba(245, 158, 11, 0.1);
        }

        .status-wrong {
            border-color: #ef4444;
            background-color: rgba(239, 68, 68, 0.1);
        }

        .btn-hover {
            transition: all 0.15s ease;
        }

        .btn-hover:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .volume-bar,
        .pitch-indicator {
            transition: all 0.1s linear;
        }

        .disabled-opacity {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        // ========== TRANSLATIONS & CONFIG ==========
        const TRANSLATIONS = {
            it: {
                title: "Training Musicale",
                settings: "Configurazione",
                key: "Tonalit√†",
                multiKey: "Tonalit√† (Selezione multipla)",
                scale: "Scala",
                major: "Maggiore",
                minor: "Minore",
                notation: "Notazione",
                instrument: "Strumento",
                guitar: "üé∏ Chitarra",
                piano: "üéπ Pianoforte",
                mode: "Modalit√†",
                auto: "‚ö° Automatica",
                manual: "‚úã Manuale",
                micLevel: "Volume Microfono",
                accuracy: "Precisione",
                playNote: "Suona una nota",
                time: "Tempo",
                prev: "Precedente",
                next: "Successiva",
                noteOf: "Nota {current} di {total}",
                start: "‚ñ∂ Inizia Sessione",
                stop: "‚èπ Stop Sessione",
                micActive: "Microfono Attivo",
                micDenied: "Permesso Negato",
                micPrompt: "Permesso Richiesto",
                reqPerm: "Richiedi Permesso",
                retry: "Riprova",
                correct: "Corretto!",
                close: "Vicino!",
                wrong: "Riprova",
                string: "Corda"
            },
            en: {
                title: "Musical Training",
                settings: "Settings",
                key: "Key",
                multiKey: "Keys (Select multiple)",
                scale: "Scale",
                major: "Major",
                minor: "Minor",
                notation: "Notation",
                instrument: "Instrument",
                guitar: "üé∏ Guitar",
                piano: "üéπ Piano",
                mode: "Mode",
                auto: "‚ö° Auto",
                manual: "‚úã Manual",
                micLevel: "Mic Level",
                accuracy: "Accuracy",
                playNote: "Play a note",
                time: "Time",
                prev: "Previous",
                next: "Next",
                noteOf: "Note {current} of {total}",
                start: "‚ñ∂ Start Session",
                stop: "‚èπ Stop Session",
                micActive: "Microphone Active",
                micDenied: "Permission Denied",
                micPrompt: "Permission Required",
                reqPerm: "Request Permission",
                retry: "Retry",
                correct: "Correct!",
                close: "Close!",
                wrong: "Try again",
                string: "String"
            }
        };

        const LanguageToggle = React.memo(({ lang, onToggle }) => (
            <button onClick={() => onToggle(lang === 'it' ? 'en' : 'it')}
                style={{ position: 'absolute', top: '20px', right: '20px', zIndex: 50 }}
                className="bg-white/20 backdrop-blur-md px-4 py-2 rounded-full text-white font-bold hover:bg-white/30 transition-all shadow-lg border border-white/10">
                {lang === 'it' ? 'üáÆüáπ IT' : 'üá¨üáß EN'}
            </button>
        ));

        // ========== MUSICAL THEORY MODULE ==========
        const musicTheory = (() => {
            const NOTES_INTERNATIONAL = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const NOTES_LATIN = ['Do', 'Do#', 'Re', 'Re#', 'Mi', 'Fa', 'Fa#', 'Sol', 'Sol#', 'La', 'La#', 'Si'];
            const SCALE_INTERVALS = {
                major: [0, 2, 4, 5, 7, 9, 11],
                minor: [0, 2, 3, 5, 7, 8, 10]
            };

            function calculateFrequency(note, octave) {
                const noteIndex = NOTES_INTERNATIONAL.indexOf(note);
                if (noteIndex === -1) return null;
                const midiNote = (octave + 1) * 12 + noteIndex;
                return 440 * Math.pow(2, (midiNote - 69) / 12);
            }

            function getNoteFromFrequency(frequency) {
                if (!frequency || frequency < 20) return null;
                const midiNote = 69 + 12 * Math.log2(frequency / 440);
                const roundedMidi = Math.round(midiNote);
                const cents = Math.round((midiNote - roundedMidi) * 100);
                const octave = Math.floor(roundedMidi / 12) - 1;
                const noteIndex = roundedMidi % 12;
                const note = NOTES_INTERNATIONAL[noteIndex];
                return { note, octave, cents, frequency: calculateFrequency(note, octave) };
            }

            function generateScale(key, scaleType = 'major') {
                const keyIndex = NOTES_INTERNATIONAL.indexOf(key);
                if (keyIndex === -1) return [];
                const intervals = SCALE_INTERVALS[scaleType] || SCALE_INTERVALS.major;
                return intervals.map(interval => {
                    const noteIndex = (keyIndex + interval) % 12;
                    return NOTES_INTERNATIONAL[noteIndex];
                });
            }

            function getValidNotes(key, scale, instrument = 'guitar') {
                const scaleNotes = generateScale(key, scale);
                const validNotes = [];
                const ranges = {
                    guitar: { min: 'E2', minOct: 2, max: 'E5', maxOct: 5 },
                    piano: { min: 'C2', minOct: 2, max: 'C6', maxOct: 6 }
                };
                const range = ranges[instrument];

                for (let octave = range.minOct; octave <= range.maxOct; octave++) {
                    scaleNotes.forEach(note => {
                        const freq = calculateFrequency(note, octave);
                        const minFreq = calculateFrequency(range.min[0], range.minOct);
                        const maxFreq = calculateFrequency(range.max[0], range.maxOct);
                        if (freq >= minFreq && freq <= maxFreq) {
                            validNotes.push({ note, octave, frequency: freq });
                        }
                    });
                }
                return validNotes;
            }

            function getGuitarString(note, octave) {
                const freq = calculateFrequency(note, octave);
                const ranges = [
                    { string: 6, min: calculateFrequency('E', 2), max: calculateFrequency('G#', 2) },
                    { string: 5, min: calculateFrequency('A', 2), max: calculateFrequency('C#', 3) },
                    { string: 4, min: calculateFrequency('D', 3), max: calculateFrequency('F#', 3) },
                    { string: 3, min: calculateFrequency('G', 3), max: calculateFrequency('B', 3) },
                    { string: 2, min: calculateFrequency('B', 3), max: calculateFrequency('D#', 4) },
                    { string: 1, min: calculateFrequency('E', 4), max: calculateFrequency('E', 5) }
                ];
                for (const r of ranges) {
                    if (freq >= r.min && freq <= r.max) return r.string;
                }
                return freq < calculateFrequency('E', 2) ? 6 : 1;
            }

            function getNoteName(note, notation = 'international') {
                if (notation === 'latin') {
                    const idx = NOTES_INTERNATIONAL.indexOf(note);
                    return idx !== -1 ? NOTES_LATIN[idx] : note;
                }
                return note;
            }

            function getRandomNote(validNotes, previousNote = null) {
                if (!validNotes || validNotes.length === 0) return null;
                let filtered = validNotes;
                if (previousNote && validNotes.length > 1) {
                    filtered = validNotes.filter(n =>
                        n.note !== previousNote.note || n.octave !== previousNote.octave
                    );
                }
                return filtered[Math.floor(Math.random() * filtered.length)];
            }

            return {
                NOTES_INTERNATIONAL, NOTES_LATIN, calculateFrequency, getNoteFromFrequency,
                getValidNotes, getGuitarString, getNoteName, getRandomNote
            };
        })();

        // ========== AUDIO ENGINE MODULE ==========
        const audioEngine = (() => {
            let audioContext = null;
            let masterGain = null;

            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGain = audioContext.createGain();
                    masterGain.gain.value = 0.3;
                    masterGain.connect(audioContext.destination);
                }
                return audioContext;
            }

            function playNote(freq, instrument = 'guitar') {
                if (!freq) return;
                if (!audioContext) initAudioContext();
                const now = audioContext.currentTime;

                if (instrument === 'guitar') {
                    // Realistic Guitar (Filtered Sawtooth + Body Resonance)
                    const osc = audioContext.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(freq, now);

                    // Pluck emulation with LowPass Filter
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(freq * 6, now); // Bright pluck start
                    filter.frequency.exponentialRampToValueAtTime(freq, now + 0.3); // Quick dampening

                    const gain = audioContext.createGain();
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.4, now + 0.01); // Sharp attack
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 2.5); // Long sustain/release

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    osc.start(now);
                    osc.stop(now + 2.5);

                    // Resonance layer (Warmth)
                    const body = audioContext.createOscillator();
                    body.type = 'triangle';
                    body.frequency.setValueAtTime(freq, now);
                    const bodyGain = audioContext.createGain();
                    bodyGain.gain.setValueAtTime(0, now);
                    bodyGain.gain.linearRampToValueAtTime(0.1, now + 0.02);
                    bodyGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);

                    body.connect(bodyGain);
                    bodyGain.connect(masterGain);
                    body.start(now);
                    body.stop(now + 1.5);

                } else {
                    // Realistic Piano (Additive Synthesis + Hammer Attack)
                    const duration = 2.5;

                    // Main string
                    const osc1 = audioContext.createOscillator();
                    osc1.type = 'sine';
                    osc1.frequency.setValueAtTime(freq, now);

                    const gain1 = audioContext.createGain();
                    gain1.gain.setValueAtTime(0, now);
                    gain1.gain.linearRampToValueAtTime(0.5, now + 0.01);
                    gain1.gain.exponentialRampToValueAtTime(0.001, now + duration);

                    // Harmonic overtone (Octave + slight detune)
                    const osc2 = audioContext.createOscillator();
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(freq * 2.003, now);

                    const gain2 = audioContext.createGain();
                    gain2.gain.setValueAtTime(0, now);
                    gain2.gain.linearRampToValueAtTime(0.15, now + 0.01);
                    gain2.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.8);

                    // Transient (Hammer click)
                    const click = audioContext.createOscillator();
                    click.type = 'square';
                    click.frequency.setValueAtTime(freq * 0.5, now);
                    const clickGain = audioContext.createGain();
                    clickGain.gain.setValueAtTime(0.05, now);
                    clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);

                    osc1.connect(gain1);
                    osc2.connect(gain2);
                    click.connect(clickGain);

                    gain1.connect(masterGain);
                    gain2.connect(masterGain);
                    clickGain.connect(masterGain);

                    osc1.start(now);
                    osc2.start(now);
                    click.start(now);

                    osc1.stop(now + duration);
                    osc2.stop(now + duration);
                    click.stop(now + 0.05);
                }
            }

            async function resumeAudioContext() {
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                } else if (!audioContext || audioContext.state === 'closed') {
                    initAudioContext();
                    if (audioContext.state === 'suspended') await audioContext.resume();
                }
            }

            function cleanupAudioContext() {
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                    masterGain = null;
                }
            }

            return { initAudioContext, playNote, resumeAudioContext, cleanupAudioContext };
        })();

        // ========== PITCH DETECTOR MODULE (Meyda-based) ==========
        const pitchDetector = (() => {
            let audioContext, microphone, mediaStream, meydaAnalyzer;
            let onPitchDetected, onVolumeUpdate;
            let previousChroma = new Float32Array(12).fill(0);
            const smoothingAlpha = 0.65;
            const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

            function analyzeAudio(features) {
                if (!features || !features.chroma) return;

                const volume = features.rms || 0;
                if (onVolumeUpdate) onVolumeUpdate(volume);

                // THRESHOLD NORMALIZZATO (era 0.001)
                // Impostalo a 0.02 o 0.03 per evitare rumori di fondo
                if (volume < 0.02) return;

                const inputChroma = features.chroma;

                // 1. Temporal Smoothing
                for (let i = 0; i < 12; i++) {
                    previousChroma[i] = (previousChroma[i] * smoothingAlpha) + (inputChroma[i] * (1 - smoothingAlpha));
                }

                // 2. Trova la nota dominante
                let maxChroma = -1;
                let dominantNote = -1;

                for (let i = 0; i < 12; i++) {
                    if (previousChroma[i] > maxChroma) {
                        maxChroma = previousChroma[i];
                        dominantNote = i;
                    }
                }

                // 3. Confidence check PI√ô ALTA (era 0.2)
                // Impostalo a 0.6 o 0.65 per essere sicuri che sia una nota pulita
                if (maxChroma > 0.6) {
                    // Calcola frequenza (assumendo ottava 3 per chitarra range medio)
                    // C3 = 48 (130.81 Hz)
                    const baseMidi = 48 + dominantNote;
                    const frequency = 440 * Math.pow(2, (baseMidi - 69) / 12);

                    console.log('üéµ MEYDA:', noteStrings[dominantNote], frequency.toFixed(2), 'Hz, Conf:', maxChroma.toFixed(3));

                    if (onPitchDetected) onPitchDetected(frequency);
                }
            }

            async function startPitchDetection(pitchCallback, volumeCallback) {
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });

                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });

                    // LowShelf Filter: +12dB boost ai bassi
                    const lowShelf = audioContext.createBiquadFilter();
                    lowShelf.type = "lowshelf";
                    lowShelf.frequency.value = 250;
                    lowShelf.gain.value = 12;

                    microphone = audioContext.createMediaStreamSource(mediaStream);
                    microphone.connect(lowShelf);

                    meydaAnalyzer = Meyda.createMeydaAnalyzer({
                        audioContext: audioContext,
                        source: lowShelf,
                        bufferSize: 8192,
                        featureExtractors: ["chroma", "rms"],
                        callback: analyzeAudio
                    });

                    onPitchDetected = pitchCallback;
                    onVolumeUpdate = volumeCallback;
                    previousChroma.fill(0);

                    meydaAnalyzer.start();
                    console.log('‚úÖ Meyda Detector STARTED');

                    return { success: true, permission: 'granted' };
                } catch (error) {
                    console.error('‚ùå Mic error:', error);
                    let permission = 'denied';
                    if (error.name === 'NotFoundError') permission = 'no-device';
                    return { success: false, permission, error: error.message };
                }
            }

            function stopPitchDetection() {
                if (meydaAnalyzer) meydaAnalyzer.stop();
                if (microphone) microphone.disconnect();
                if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
                if (audioContext) audioContext.close();
                console.log('üõë Detector stopped');
            }

            return { startPitchDetection, stopPitchDetection };
        })();

        // ========== REACT COMPONENTS ==========
        const { useState, useEffect, useRef, useMemo, useCallback, memo } = React;

        const NoteDisplay = memo(({ note, notation, feedbackStatus, instrument, labels, onPlay }) => {
            if (!note) return null;
            const noteName = musicTheory.getNoteName(note.note, notation);
            const guitarString = instrument === 'guitar' ? musicTheory.getGuitarString(note.note, note.octave) : null;
            const statusClass = `status-${feedbackStatus}`;

            return (
                <div className={`relative p-8 rounded-3xl border-4 color-transition note-enter ${statusClass} 
            ${feedbackStatus === 'correct' ? 'feedback-correct glow-effect' : ''}`}>
                    <button
                        onClick={(e) => { e.stopPropagation(); onPlay && onPlay(); }}
                        className="absolute top-4 right-4 bg-white/20 hover:bg-white/30 text-white rounded-full p-2 transition-all hover:scale-110 shadow-lg z-10"
                        title={labels.playNote}
                    >
                        <span className="text-xl">üîä</span>
                    </button>
                    <div className="text-center">
                        <div className="text-8xl md:text-9xl font-bold text-white mb-4">
                            {noteName}
                            <span className="text-5xl md:text-6xl ml-2 text-white/80">{note.octave}</span>
                        </div>
                        {guitarString && (
                            <div className="text-2xl md:text-3xl text-white/90 font-medium">
                                {labels.string} {guitarString}
                            </div>
                        )}
                    </div>
                </div>
            );
        });

        const KeySelector = memo(({ selectedKeys, onToggle, labels }) => {
            const keys = musicTheory.NOTES_INTERNATIONAL;
            return (
                <div className="space-y-2">
                    <label className="block text-white font-semibold text-sm">
                        {labels.multiKey}
                    </label>
                    <div className="grid grid-cols-6 gap-2">
                        {keys.map(key => {
                            const isSelected = selectedKeys.includes(key);
                            return (
                                <button key={key} onClick={() => onToggle(key)}
                                    className={`px-3 py-2 rounded-lg font-semibold text-sm btn-hover transition-all
                                ${isSelected
                                            ? 'bg-white text-indigo-600 shadow-lg scale-105'
                                            : 'bg-white/20 text-white hover:bg-white/30'}`}>
                                    {key}
                                </button>
                            );
                        })}
                    </div>
                </div>
            );
        });

        const ScaleSelector = memo(({ selectedScale, onChange, labels }) => (
            <div className="space-y-2">
                <label className="block text-white font-semibold text-sm">{labels.scale}</label>
                <div className="flex gap-2">
                    {['major', 'minor'].map(scale => (
                        <button key={scale} onClick={() => onChange(scale)}
                            className={`flex-1 px-4 py-3 rounded-lg font-semibold btn-hover
                        ${selectedScale === scale ? 'bg-white text-indigo-600 shadow-lg' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                            {scale === 'major' ? labels.major : labels.minor}
                        </button>
                    ))}
                </div>
            </div>
        ));

        const NotationToggle = memo(({ notation, onChange, labels }) => (
            <div className="space-y-2">
                <label className="block text-white font-semibold text-sm">{labels.notation}</label>
                <div className="flex gap-2">
                    <button onClick={() => onChange('international')}
                        className={`flex-1 px-4 py-3 rounded-lg font-semibold btn-hover
                    ${notation === 'international' ? 'bg-white text-indigo-600 shadow-lg' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                        C D E F G A B
                    </button>
                    <button onClick={() => onChange('latin')}
                        className={`flex-1 px-4 py-3 rounded-lg font-semibold btn-hover
                    ${notation === 'latin' ? 'bg-white text-indigo-600 shadow-lg' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                        Do Re Mi Fa Sol La Si
                    </button>
                </div>
            </div>
        ));

        const InstrumentSelector = memo(({ instrument, onChange, labels }) => (
            <div className="space-y-2">
                <label className="block text-white font-semibold text-sm">{labels.instrument}</label>
                <div className="flex gap-2">
                    {[{ id: 'guitar', label: labels.guitar }, { id: 'piano', label: labels.piano }].map(inst => (
                        <button key={inst.id} onClick={() => onChange(inst.id)}
                            className={`flex-1 px-4 py-3 rounded-lg font-semibold btn-hover
                        ${instrument === inst.id ? 'bg-white text-indigo-600 shadow-lg' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                            {inst.label}
                        </button>
                    ))}
                </div>
            </div>
        ));

        const ModeToggle = memo(({ autoMode, onChange, labels }) => (
            <div className="space-y-2">
                <label className="block text-white font-semibold text-sm">{labels.mode}</label>
                <div className="flex gap-2">
                    <button onClick={() => onChange(true)}
                        className={`flex-1 px-4 py-3 rounded-lg font-semibold btn-hover
                    ${autoMode ? 'bg-white text-indigo-600 shadow-lg' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                        {labels.auto}
                    </button>
                    <button onClick={() => onChange(false)}
                        className={`flex-1 px-4 py-3 rounded-lg font-semibold btn-hover
                    ${!autoMode ? 'bg-white text-indigo-600 shadow-lg' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                        {labels.manual}
                    </button>
                </div>
            </div>
        ));

        const VolumeIndicator = memo(({ volume, labels }) => {
            const percentage = Math.min(100, volume * 500);
            return (
                <div className="space-y-2">
                    <label className="block text-white font-semibold text-sm">{labels.micLevel}</label>
                    <div className="bg-white/10 rounded-lg p-3">
                        <div className="h-3 bg-white/20 rounded-full overflow-hidden">
                            <div className="volume-bar h-full rounded-full" style={{
                                width: `${percentage}%`,
                                backgroundColor: percentage > 70 ? '#10b981' : percentage > 30 ? '#f59e0b' : '#ef4444'
                            }} />
                        </div>
                    </div>
                </div>
            );
        });

        const PitchIndicator = memo(({ detectedNote, targetNote, labels }) => {
            if (!detectedNote || !targetNote) {
                return (
                    <div className="bg-white/10 rounded-lg p-6">
                        <div className="text-center text-white/60">{labels.playNote}</div>
                    </div>
                );
            }

            const cents = detectedNote.cents || 0;
            const percentage = Math.max(0, Math.min(100, 50 + cents));
            const color = Math.abs(cents) <= 25 ? '#10b981' : Math.abs(cents) <= 50 ? '#f59e0b' : '#ef4444';

            return (
                <div className="space-y-2">
                    <label className="block text-white font-semibold text-sm">{labels.accuracy}</label>
                    <div className="bg-white/10 rounded-lg p-4">
                        <div className="relative h-4 bg-white/20 rounded-full overflow-hidden">
                            <div className="pitch-indicator absolute h-full w-1 shadow-lg"
                                style={{ left: `${percentage}%`, backgroundColor: color, transform: 'translateX(-50%)' }} />
                        </div>
                        <div className="mt-2 text-center text-white/90 font-mono text-sm">
                            {cents > 0 ? '+' : ''}{cents} cents
                        </div>
                    </div>
                </div>
            );
        });

        const Timer = memo(({ time, labels }) => {
            const formatTime = (ms) => {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const deciseconds = Math.floor((ms % 1000) / 100);
                return minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}.${deciseconds}` : `${seconds}.${deciseconds}`;
            };

            return (
                <div className="bg-white/10 rounded-lg px-6 py-3 inline-block">
                    <div className="text-center">
                        <div className="text-sm text-white/70 mb-1">{labels.time}</div>
                        <div className="text-3xl font-bold text-white mono-font">{formatTime(time)}</div>
                    </div>
                </div>
            );
        });

        const FeedbackDisplay = memo(({ status, message, labels }) => {
            if (status === 'idle') return null;
            const c = {
                correct: { color: '#10b981', emoji: '‚úì', text: labels.correct },
                close: { color: '#f59e0b', emoji: '~', text: labels.close },
                wrong: { color: '#ef4444', emoji: '‚úó', text: labels.wrong }
            }[status] || { color: '#ef4444', emoji: '‚úó', text: labels.wrong };

            return (
                <div className={`bg-white/90 rounded-xl p-4 shadow-xl ${status === 'correct' ? 'feedback-bounce' : 'slide-in-up'}`}>
                    <div className="flex items-center justify-center gap-3">
                        <span className="text-3xl">{c.emoji}</span>
                        <span className="text-xl font-bold" style={{ color: c.color }}>{c.text}</span>
                    </div>
                </div>
            );
        });

        const NavigationButtons = memo(({ onPrevious, onNext, canGoPrevious, canGoNext, autoMode, currentIndex, totalNotes, labels }) => (
            <div className="space-y-3">
                <div className="flex gap-3">
                    <button onClick={onPrevious} disabled={!canGoPrevious}
                        className={`flex-1 px-6 py-3 rounded-lg font-semibold btn-hover flex items-center justify-center gap-2
                    ${!canGoPrevious ? 'bg-white/10 text-white/40 disabled-opacity' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                        <span>‚óÄ</span><span>{labels.prev}</span>
                    </button>
                    <button onClick={onNext} disabled={!canGoNext || autoMode}
                        className={`flex-1 px-6 py-3 rounded-lg font-semibold btn-hover flex items-center justify-center gap-2
                    ${!canGoNext || autoMode ? 'bg-white/10 text-white/40 disabled-opacity' : 'bg-white/20 text-white hover:bg-white/30'}`}>
                        <span>{labels.next}</span><span>‚ñ∂</span>
                    </button>
                </div>
                <div className="text-center text-white/80 text-sm">
                    {labels.noteOf.replace('{current}', currentIndex + 1).replace('{total}', totalNotes)}
                </div>
            </div>
        ));

        const MicrophoneStatus = memo(({ permission, onRequestPermission, labels }) => {
            const c = {
                granted: { color: '#10b981', icon: 'üé§', text: labels.micActive, button: false },
                denied: { color: '#ef4444', icon: 'üö´', text: labels.micDenied, button: true, buttonText: labels.retry },
                prompt: { color: '#f59e0b', icon: '‚ö†Ô∏è', text: labels.micPrompt, button: true, buttonText: labels.reqPerm }
            }[permission] || { color: '#f59e0b', icon: '‚ö†Ô∏è', text: labels.micPrompt, button: true, buttonText: labels.reqPerm };

            return (
                <div className="bg-white/10 rounded-lg p-4">
                    <div className="flex items-center justify-between gap-3">
                        <div className="flex items-center gap-2">
                            <span className="text-2xl">{c.icon}</span>
                            <span className="text-white font-medium text-sm">{c.text}</span>
                        </div>
                        {c.button && (
                            <button onClick={onRequestPermission}
                                className="px-4 py-2 bg-white text-indigo-600 rounded-lg font-semibold text-sm btn-hover">
                                {c.buttonText}
                            </button>
                        )}
                    </div>
                </div>
            );
        });

        const SessionControls = memo(({ isActive, onStart, onStop, labels }) => (
            <button onClick={isActive ? onStop : onStart}
                className={`w-full px-8 py-4 rounded-xl font-bold text-lg btn-hover shadow-xl
            ${isActive ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}`}>
                {isActive ? labels.stop : labels.start}
            </button>
        ));

        // ========== MAIN APP ==========
        function App() {
            const [lang, setLang] = useState('it');
            const t = TRANSLATIONS[lang];
            const [selectedKeys, setSelectedKeys] = useState(['C']); // Changed to Array
            const [scale, setScale] = useState('major');
            const [notation, setNotation] = useState('international');
            const [instrument, setInstrument] = useState('guitar');
            const [autoMode, setAutoMode] = useState(true);
            const [isActive, setIsActive] = useState(false);
            const [currentNote, setCurrentNote] = useState(null);
            const currentNoteRef = useRef(null); // Fix stale closure bug
            const isProcessingRef = useRef(false); // Lock per debounce
            const isSystemPlayingRef = useRef(false); // Lock per evitare feedback loop
            const systemPlayTimeoutRef = useRef(null); // Ref per il timer del lock audio
            const [noteHistory, setNoteHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [micPermission, setMicPermission] = useState('prompt');
            const [detectedPitch, setDetectedPitch] = useState(null);
            const [detectedNote, setDetectedNote] = useState(null);
            const [feedbackStatus, setFeedbackStatus] = useState('idle');
            const [feedbackMessage, setFeedbackMessage] = useState('');
            const [volume, setVolume] = useState(0);
            const [timerValue, setTimerValue] = useState(0);
            const [isTimerRunning, setIsTimerRunning] = useState(false);
            const timerStartRef = useRef(null);
            const timerIntervalRef = useRef(null);

            const validNotes = useMemo(() => {
                // Combine valid notes from ALL selected keys
                const allNotes = selectedKeys.flatMap(k => musicTheory.getValidNotes(k, scale, instrument));

                // Deduplicate notes (same note+octave might appear in different keys)
                const uniqueNotes = [];
                const seen = new Set();
                for (const n of allNotes) {
                    const id = `${n.note}${n.octave}`;
                    if (!seen.has(id)) {
                        seen.add(id);
                        uniqueNotes.push(n);
                    }
                }
                return uniqueNotes;
            }, [selectedKeys, scale, instrument]);

            const playSystemNote = useCallback((freq, inst) => {
                // Cancella timer precedente se l'utente clicca velocemente
                if (systemPlayTimeoutRef.current) {
                    clearTimeout(systemPlayTimeoutRef.current);
                }

                isSystemPlayingRef.current = true;

                // Blocca il rilevamento per 2000ms (2 secondi) come richiesto
                systemPlayTimeoutRef.current = setTimeout(() => {
                    isSystemPlayingRef.current = false;
                    systemPlayTimeoutRef.current = null;
                }, 2000);

                audioEngine.resumeAudioContext().then(() => {
                    audioEngine.playNote(freq, inst);
                }).catch(err => console.error("Audio playback error:", err));
            }, []);

            const toggleKey = useCallback((k) => {
                setSelectedKeys(prev => {
                    if (prev.includes(k)) {
                        // Prevent deselecting the last key (must have at least one)
                        if (prev.length === 1) return prev;
                        return prev.filter(key => key !== k);
                    } else {
                        return [...prev, k];
                    }
                });
            }, []);

            const generateNewNote = useCallback(() => {
                const newNote = musicTheory.getRandomNote(validNotes, currentNote);
                if (!newNote) return;

                setCurrentNote(newNote);
                currentNoteRef.current = newNote; // Keep ref in sync
                setNoteHistory(prev => [...prev, newNote]);
                setHistoryIndex(prev => prev + 1);
                isProcessingRef.current = false; // Unlock detection

                // Auto-playback removed per user request
                // playSystemNote(newNote.frequency, instrument); 

                setFeedbackStatus('idle');
                setFeedbackMessage('');
                setIsTimerRunning(true);
                timerStartRef.current = Date.now();
            }, [validNotes, currentNote, instrument]);

            useEffect(() => {
                if (isTimerRunning) {
                    timerIntervalRef.current = setInterval(() => {
                        if (timerStartRef.current) {
                            setTimerValue(Date.now() - timerStartRef.current);
                        }
                    }, 100);
                } else {
                    if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
                }
                return () => {
                    if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
                };
            }, [isTimerRunning]);

            const stopTimer = useCallback(() => setIsTimerRunning(false), []);
            const resetTimer = useCallback(() => {
                setTimerValue(0);
                timerStartRef.current = null;
            }, []);

            const handlePitchDetected = useCallback((frequency) => {
                // Ignore if processing success OR if system is playing audio (feedback prevention)
                if (isProcessingRef.current || isSystemPlayingRef.current) return;

                const target = currentNoteRef.current; // Use ref instead of state
                console.log('üìä handlePitchDetected called - Target:', target ? `${target.note}${target.octave}` : 'NULL');
                if (!target) {
                    console.warn('‚ö†Ô∏è No target note set!');
                    return;
                }

                setDetectedPitch(frequency);
                const detected = musicTheory.getNoteFromFrequency(frequency);
                setDetectedNote(detected);

                if (!detected) {
                    console.warn('‚ö†Ô∏è Could not detect note from frequency:', frequency);
                    return;
                }

                const isCorrectNote = detected.note === target.note;
                const cents = Math.abs(detected.cents);

                console.log('üéØ Comparison:', {
                    detected: `${detected.note}${detected.octave}`,
                    target: `${target.note}${target.octave}`,
                    isCorrectNote,
                    cents,
                    frequency: frequency.toFixed(2)
                });

                if (isCorrectNote && cents <= 25) {
                    console.log('‚úÖ CORRECT! Setting feedback to correct');
                    isProcessingRef.current = true; // Lock immediately
                    setFeedbackStatus('correct');
                    setFeedbackMessage('Corretto! / Correct!');
                    stopTimer();
                    if (autoMode) {
                        // Delay aumentato a 1.5s (1500ms) come richiesto
                        setTimeout(() => generateNewNote(), 1500);
                    }
                } else if (isCorrectNote && cents <= 50) {
                    console.log('üü° CLOSE! cents:', cents);
                    setFeedbackStatus('close');
                    setFeedbackMessage('Vicino! / Close!');
                }
                // REMOVED ELSE BLOCK: No negative feedback for wrong notes
            }, [autoMode, generateNewNote, stopTimer]);

            const handleVolumeUpdate = useCallback(vol => setVolume(vol), []);

            const startSession = useCallback(async () => {
                audioEngine.initAudioContext();
                const result = await pitchDetector.startPitchDetection(handlePitchDetected, handleVolumeUpdate);
                setMicPermission(result.permission);
                if (result.success) {
                    setIsActive(true);
                    generateNewNote();
                }
            }, [handlePitchDetected, handleVolumeUpdate, generateNewNote]);

            const stopSession = useCallback(() => {
                pitchDetector.stopPitchDetection();
                setIsActive(false);
                setCurrentNote(null);
                currentNoteRef.current = null; // Clear ref too
                setNoteHistory([]);
                setHistoryIndex(-1);
                setFeedbackStatus('idle');
                setDetectedPitch(null);
                setDetectedNote(null);
                stopTimer();
                resetTimer();
            }, [stopTimer, resetTimer]);

            const goToPreviousNote = useCallback(() => {
                if (historyIndex <= 0) return;
                const newIndex = historyIndex - 1;
                const note = noteHistory[newIndex];
                setHistoryIndex(newIndex);
                setCurrentNote(note);
                currentNoteRef.current = note; // Keep ref in sync
                setFeedbackStatus('idle');
                stopTimer();
                resetTimer();
                playSystemNote(note.frequency, instrument);
            }, [historyIndex, noteHistory, instrument, stopTimer, resetTimer, playSystemNote]);

            const goToNextNote = useCallback(() => {
                if (autoMode) return;
                if (historyIndex < noteHistory.length - 1) {
                    const newIndex = historyIndex + 1;
                    const note = noteHistory[newIndex];
                    setHistoryIndex(newIndex);
                    setCurrentNote(note);
                    currentNoteRef.current = note; // Keep ref in sync
                    setFeedbackStatus('idle');
                    stopTimer();
                    resetTimer();
                    playSystemNote(note.frequency, instrument);
                } else {
                    generateNewNote();
                }
            }, [autoMode, historyIndex, noteHistory, instrument, generateNewNote, stopTimer, resetTimer, playSystemNote]);

            const requestMicPermission = useCallback(async () => {
                const result = await pitchDetector.startPitchDetection(handlePitchDetected, handleVolumeUpdate);
                setMicPermission(result.permission);
            }, [handlePitchDetected, handleVolumeUpdate]);

            useEffect(() => {
                return () => {
                    pitchDetector.stopPitchDetection();
                    audioEngine.cleanupAudioContext();
                };
            }, []);

            return (
                <div className="min-h-screen p-4 md:p-8 relative">
                    <LanguageToggle lang={lang} onToggle={setLang} />
                    <div className="max-w-7xl mx-auto">
                        <div className="text-center mb-8">
                            <h1 className="text-4xl md:text-5xl font-bold text-white mb-2">üéµ {t.title}</h1>
                        </div>

                        <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
                            <div className="lg:col-span-3 space-y-4">
                                <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 space-y-4">
                                    <h2 className="text-xl font-bold text-white mb-4">{t.settings}</h2>
                                    <KeySelector
                                        selectedKeys={selectedKeys}
                                        onToggle={toggleKey}
                                        labels={t}
                                    />
                                    <ScaleSelector selectedScale={scale} onChange={setScale} labels={t} />
                                    <NotationToggle notation={notation} onChange={setNotation} labels={t} />
                                    <InstrumentSelector instrument={instrument} onChange={setInstrument} labels={t} />
                                    <ModeToggle autoMode={autoMode} onChange={setAutoMode} labels={t} />
                                </div>
                            </div>

                            <div className="lg:col-span-6 space-y-6">
                                <div className="flex justify-center"><Timer time={timerValue} labels={t} /></div>

                                <div className="flex justify-center">
                                    {currentNote ? (
                                        <NoteDisplay
                                            note={currentNote}
                                            notation={notation}
                                            feedbackStatus={feedbackStatus}
                                            instrument={instrument}
                                            labels={t}
                                            onPlay={() => playSystemNote(currentNote.frequency, instrument)}
                                        />
                                    ) : (
                                        <div className="bg-white/10 backdrop-blur-lg rounded-3xl p-12 text-center">
                                            <p className="text-2xl text-white/60">{t.start}</p>
                                        </div>
                                    )}
                                </div>

                                <div className="flex justify-center">
                                    <FeedbackDisplay status={feedbackStatus} message={feedbackMessage} labels={t} />
                                </div>

                                {isActive && (
                                    <NavigationButtons onPrevious={goToPreviousNote} onNext={goToNextNote}
                                        canGoPrevious={historyIndex > 0} canGoNext={!autoMode && historyIndex >= 0}
                                        autoMode={autoMode} currentIndex={historyIndex} totalNotes={noteHistory.length} labels={t} />
                                )}

                                <SessionControls isActive={isActive} onStart={startSession} onStop={stopSession} labels={t} />
                            </div>

                            <div className="lg:col-span-3 space-y-4">
                                <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 space-y-4">
                                    <h2 className="text-xl font-bold text-white mb-4">Status</h2>
                                    <MicrophoneStatus permission={micPermission} onRequestPermission={requestMicPermission} labels={t} />
                                    {isActive && (
                                        <>
                                            <VolumeIndicator volume={volume} labels={t} />
                                            <PitchIndicator detectedNote={detectedNote} targetNote={currentNote} labels={t} />
                                        </>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // ========== RENDER ==========
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>